<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Connection Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
        }
        .test {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        .warning { background: #fff3cd; color: #856404; }
        button {
            padding: 10px 20px;
            margin: 10px 5px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        button:disabled {
            background: #ccc;
        }
        #log {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .log-entry {
            margin: 2px 0;
            padding: 2px;
        }
    </style>
</head>
<body>
    <h1>Mobile Connection Test</h1>
    
    <div class="test info">
        <h3>Device Info</h3>
        <div id="deviceInfo"></div>
    </div>

    <div class="test">
        <h3>1. WebSocket Connection Test</h3>
        <button onclick="testWebSocket()">Test WebSocket</button>
        <div id="wsResult"></div>
    </div>

    <div class="test">
        <h3>2. Media Permissions Test</h3>
        <button onclick="testMedia()">Test Camera/Mic</button>
        <div id="mediaResult"></div>
    </div>

    <div class="test">
        <h3>3. API Connection Test</h3>
        <button onclick="testAPI()">Test API</button>
        <div id="apiResult"></div>
    </div>

    <div class="test">
        <h3>4. Full Conference Test</h3>
        <button onclick="testFullConference()">Test Full Flow</button>
        <div id="fullResult"></div>
    </div>

    <div class="test">
        <h3>Debug Log</h3>
        <div id="log"></div>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const log = (message, type = 'info') => {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entry.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'black';
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        };

        // Device info
        const deviceInfo = document.getElementById('deviceInfo');
        deviceInfo.innerHTML = `
            <p>User Agent: ${navigator.userAgent}</p>
            <p>Platform: ${navigator.platform}</p>
            <p>Screen: ${screen.width}x${screen.height}</p>
            <p>Window: ${window.innerWidth}x${window.innerHeight}</p>
            <p>Protocol: ${location.protocol}</p>
            <p>Host: ${location.host}</p>
        `;

        // Get WebSocket URL
        const getWSUrl = () => {
            const host = window.location.hostname;
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            return `${window.location.protocol}//${host}:3001`;
        };

        async function testWebSocket() {
            const resultDiv = document.getElementById('wsResult');
            resultDiv.innerHTML = 'Testing...';
            
            try {
                const wsUrl = getWSUrl();
                log(`Connecting to WebSocket at ${wsUrl}`);
                
                const socket = io(wsUrl, {
                    transports: ['websocket', 'polling'],
                    reconnection: false,
                    timeout: 5000
                });

                socket.on('connect', () => {
                    log('WebSocket connected!', 'success');
                    resultDiv.innerHTML = '<div class="success">✅ WebSocket Connected</div>';
                    resultDiv.innerHTML += `<p>Socket ID: ${socket.id}</p>`;
                    resultDiv.innerHTML += `<p>Transport: ${socket.io.engine.transport.name}</p>`;
                    socket.disconnect();
                });

                socket.on('connect_error', (error) => {
                    log(`WebSocket error: ${error.message}`, 'error');
                    resultDiv.innerHTML = `<div class="error">❌ Connection Failed: ${error.message}</div>`;
                });

                setTimeout(() => {
                    if (!socket.connected) {
                        log('WebSocket timeout', 'error');
                        resultDiv.innerHTML = '<div class="error">❌ Connection Timeout</div>';
                        socket.disconnect();
                    }
                }, 5000);
            } catch (error) {
                log(`WebSocket test error: ${error.message}`, 'error');
                resultDiv.innerHTML = `<div class="error">❌ Error: ${error.message}</div>`;
            }
        }

        async function testMedia() {
            const resultDiv = document.getElementById('mediaResult');
            resultDiv.innerHTML = 'Testing...';
            
            try {
                // Check if getUserMedia is available
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    const isHTTPS = location.protocol === 'https:';
                    const message = `getUserMedia not available. ${!isHTTPS ? 'HTTPS required for camera/mic access on mobile.' : 'Browser may not support WebRTC.'}`;
                    log(message, 'error');
                    resultDiv.innerHTML = `<div class="error">❌ ${message}</div>`;
                    resultDiv.innerHTML += '<p><strong>Note:</strong> Mobile browsers require HTTPS for camera/microphone access.</p>';
                    resultDiv.innerHTML += '<p>Workarounds:</p>';
                    resultDiv.innerHTML += '<ul><li>Use localhost instead of IP on the same device</li>';
                    resultDiv.innerHTML += '<li>Set up HTTPS with a self-signed certificate</li>';
                    resultDiv.innerHTML += '<li>Deploy to a service with HTTPS (Vercel, etc.)</li></ul>';
                    return;
                }
                
                log('Requesting media permissions...');
                
                // Try video and audio
                let stream;
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: true, 
                        audio: true 
                    });
                    log('Got video and audio', 'success');
                    resultDiv.innerHTML = '<div class="success">✅ Camera and Microphone Access</div>';
                } catch (e) {
                    log(`Video/audio failed: ${e.message}, trying audio only...`, 'warning');
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ 
                            audio: true 
                        });
                        log('Got audio only', 'success');
                        resultDiv.innerHTML = '<div class="warning">⚠️ Audio Only (No Camera)</div>';
                    } catch (e2) {
                        throw e2;
                    }
                }

                // Display stream info
                const tracks = stream.getTracks();
                resultDiv.innerHTML += '<p>Tracks:</p><ul>';
                tracks.forEach(track => {
                    resultDiv.innerHTML += `<li>${track.kind}: ${track.label}</li>`;
                    track.stop(); // Clean up
                });
                resultDiv.innerHTML += '</ul>';
                
            } catch (error) {
                log(`Media test error: ${error.message}`, 'error');
                resultDiv.innerHTML = `<div class="error">❌ Media Error: ${error.message}</div>`;
            }
        }

        async function testAPI() {
            const resultDiv = document.getElementById('apiResult');
            resultDiv.innerHTML = 'Testing...';
            
            try {
                log('Testing API endpoints...');
                
                // Test TURN API
                const turnResponse = await fetch('/api/turn');
                const turnData = await turnResponse.json();
                log(`TURN API: ${turnResponse.ok ? 'OK' : 'Failed'}`, turnResponse.ok ? 'success' : 'error');
                
                // Test room creation
                const roomResponse = await fetch('/api/rooms', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const roomData = await roomResponse.json();
                log(`Room API: ${roomResponse.ok ? 'OK' : 'Failed'}`, roomResponse.ok ? 'success' : 'error');
                
                if (roomResponse.ok && turnResponse.ok) {
                    resultDiv.innerHTML = '<div class="success">✅ All APIs Working</div>';
                    resultDiv.innerHTML += `<p>Test Room: ${roomData.roomId}</p>`;
                    resultDiv.innerHTML += `<p>ICE Servers: ${turnData.iceServers.length}</p>`;
                } else {
                    resultDiv.innerHTML = '<div class="warning">⚠️ Some APIs Failed</div>';
                }
            } catch (error) {
                log(`API test error: ${error.message}`, 'error');
                resultDiv.innerHTML = `<div class="error">❌ API Error: ${error.message}</div>`;
            }
        }

        async function testFullConference() {
            const resultDiv = document.getElementById('fullResult');
            resultDiv.innerHTML = 'Running full test...';
            
            try {
                log('Starting full conference test...');
                
                // 1. Create room
                log('Creating room...');
                const roomResponse = await fetch('/api/rooms', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const roomData = await roomResponse.json();
                log(`Room created: ${roomData.roomId}`, 'success');
                
                // 2. Get TURN credentials
                log('Getting TURN credentials...');
                const turnResponse = await fetch('/api/turn');
                const turnData = await turnResponse.json();
                log(`Got ${turnData.iceServers.length} ICE servers`, 'success');
                
                // 3. Get media (skip if not available)
                log('Getting user media...');
                let stream = null;
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { facingMode: 'user' }, 
                            audio: true 
                        });
                        log(`Got ${stream.getTracks().length} tracks`, 'success');
                    } catch (e) {
                        try {
                            stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            log(`Got audio only: ${stream.getTracks().length} tracks`, 'success');
                        } catch (e2) {
                            log('Media access failed, continuing without media', 'warning');
                        }
                    }
                } else {
                    log('getUserMedia not available (HTTP/browser issue), continuing without media', 'warning');
                }
                
                // 4. Connect to signaling
                log('Connecting to signaling server...');
                const wsUrl = getWSUrl();
                const socket = io(wsUrl, {
                    transports: ['websocket', 'polling'],
                    timeout: 5000
                });
                
                await new Promise((resolve, reject) => {
                    socket.on('connect', () => {
                        log('Connected to signaling', 'success');
                        socket.emit('join-room', {
                            roomId: roomData.roomId,
                            pin: roomData.hostPin,
                            userId: 'test-user'
                        });
                    });
                    
                    socket.on('current-participants', ({ participants }) => {
                        log(`Joined room, participants: ${participants.length}`, 'success');
                        resolve();
                    });
                    
                    socket.on('connect_error', reject);
                    setTimeout(() => reject(new Error('Timeout')), 5000);
                });
                
                // Clean up
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                socket.disconnect();
                
                resultDiv.innerHTML = '<div class="success">✅ Full Test Passed!</div>';
                resultDiv.innerHTML += `<p>Room: ${roomData.roomId}</p>`;
                resultDiv.innerHTML += '<p>All systems operational</p>';
                
            } catch (error) {
                log(`Full test error: ${error.message}`, 'error');
                resultDiv.innerHTML = `<div class="error">❌ Test Failed: ${error.message}</div>`;
                resultDiv.innerHTML += '<p>Check the log above for details</p>';
            }
        }
    </script>
</body>
</html>
